#!/usr/bin/env perl
use v5.14;
use lib 'local/lib/perl5'; 

our $VERSION = '0.0.1';

## get options
use Getopt::Long;
use Pod::Usage;

my %opt;
GetOptions(\%opt, 
    'help|h|?',
    'sparql=s',
    'scheme=s',
    'directory|d=s',
    'quiet|q',
    'verbose|v',
) or exit;
pod2usage(1) if $opt{help} or (!$opt{sparql} && !@ARGV);

$opt{directory} //= '.';
$opt{directory} =~ s{/$}{};
die "output directory not found: ".$opt{output} unless -d $opt{directory};

## Logging methods
use Term::ANSIColor;
my $colored = -t STDOUT;

sub error($) {
    say STDERR ($colored ? colored($_[0],'red') : $_[0]);
}

sub info($) {
    return if $opt{quiet};
    say STDERR ($colored ? colored($_[0],'yellow') : $_[0]);
}

sub trace($) {
    return unless $opt{verbose};
    say STDERR ($colored ? colored($_[0],'white') : $_[0]);
}

## check where to get RDF data from
use RDF::Trine;
use RDF::Query;
use RDF::Query::Client;

my $source = $opt{sparql} || RDF::Trine::Model->new;

if ($opt{sparql}) {
    info "Getting RDF from SPARQL endpoint ".$opt{sparql};
} else {
    info "Reading RDF files";
    my $size = 0;
    foreach my $file (@ARGV) {
        my $parser = RDF::Trine::Parser->guess_parser_by_filename($file);
        $parser->parse_file_into_model("file://$file", $file, $source);
        trace $source->size-$size." triples from $file";
        $size = $source->size;
    }
}

### SPARQL query method
sub sparql {
    my ($query) = @_;

    $query = <<'SPARQL'.$query."\n}";
PREFIX skos: <http://www.w3.org/2004/02/skos/core#>
PREFIX dct: <http://purl.org/dc/terms/>
SELECT * WHERE {
SPARQL

#    trace $query;

    my $q = $opt{sparql}
          ? RDF::Query::Client->new($query)
          : RDF::Query->new($query); 

    $q->execute($source) // RDF::Trine::Iterator->new([],'bindings',[]);
}


## Conversion methods
sub prefLabel {
    my ($entity, $label) = @_;
    return unless $label;    
    my $language = $label->literal_value_language;
    $entity->{prefLabel} //= {};
    # TODO: warn if multiple languages
    $entity->{prefLabel}->{$language} = $label->literal_value;
}

sub uriList {
    my ($entity, $property, $node) = @_;
    return unless $node;
    push @{$entity->{$property}}, $node->uri_value;
}

sub notation {
    my ($entity, $label) = @_;
    return unless $label;
    push @{$entity->{notation}}, $label->literal_value;
}

## Export JSKOS method
use JSON;
my $JSON = JSON->new->pretty->utf8->canonical;

sub export {
    my ($file, $jskos) = @_;
    $file = $opt{directory}.'/'.$file;
    open my $fh, '>', $file;
    say $fh $JSON->encode($jskos);
    trace $file;
}    

## convert concept scheme
info "Converting concept scheme";

unless ($opt{scheme}) {
    error "Please choose a concept scheme with option --scheme:";
    my $res = sparql('?s a skos:ConceptScheme .');
    $res->each(sub { say $_[0]->{s}->uri_value; });
    exit 1;
}

my $scheme = {
    '@context' => 'https://gbv.github.io/jskos/context.json',
    uri        => $opt{scheme},
    type       => ['http://www.w3.org/2004/02/skos/core#ConceptScheme'],
};

my $res = sparql("<$opt{scheme}> dct:title ?t .");
$res->each(sub { prefLabel($scheme, $_[0]->{t}) });

$res = sparql("<$opt{scheme}> skos:hasTopConcept ?c .");
$res->each(sub { uriList($scheme, 'topConcepts', $_[0]->{c}) });

# TODO: notation, altLabel, description...

info "Exporting JSKOS scheme";
export('jskos-scheme.json', $scheme);


## convert concepts
info "Converting concepts";

my $concepts = { };

# TODO: just all concepts instead of inScheme
# TODO: broader, altLabel etc.
my $res = sparql(<<SPARQL);
?c skos:inScheme <$opt{scheme}> .
OPTIONAL { ?c skos:prefLabel ?pLabel } .
OPTIONAL { ?c skos:notation ?notation } .
OPTIONAL { ?c skos:narrower ?narrower } .
SPARQL
$res->each(sub {
    my $row = shift;
    my $uri = $row->{c}->uri_value;

    unless (defined $concepts->{$uri}) {
        trace "$uri";
        $concepts->{$uri} = {
            uri  => $uri,
            type => ['http://www.w3.org/2004/02/skos/core#Concept'],
        };
    }

    my $concept = $concepts->{$uri};

    notation($concept, $row->{notation});
    prefLabel($concept, $row->{pLabel});
    uriList($concept, 'narrower', $row->{narrower});
});

info "Exporting ".scalar(values %$concepts)." JSKOS concepts";
export('jskos-concepts.json', [ values %$concepts ]);

__END__

=head1 NAME

skos2jskos - convert SKOS/RDF to JSKOS

=head1 SYNOPSIS

  skos2jskos OPTIONS [ RDFFILE ]

=head1 OPTIONS

=over

=item --directory | -d

Output directory to write JSKOS files to

=item --quiet | -q

Don't show status messages

=item --verbose | -v

Show detailed processing messages

=item --scheme

Concept scheme URI

=item --sparql

SPARQL endpoint

=item --help | -h | -?

Show usage description

=back

=cut
